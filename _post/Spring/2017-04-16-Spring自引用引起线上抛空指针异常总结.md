### Spring自引用引起线上抛空指针异常总结

#### 背景

2017年4月13号下午19点，发布一个分支修复线上问题，从19点28分开始，用户反馈预订机票失败，通过埋点定位到具体代码：使用的自引用对象没有被赋值，抛空异常了。

自引用初始化代码：

	@Component
	public class ProxyInjectJBeanPostProcessor implements BeanPostProcessor, Ordered {
    	@Override
    	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        	return bean;
    	}

        @Override
        public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
            if (AopUtils.isAopProxy(bean)) {
                try {
                    Object target = ((Advised) bean).getTargetSource().getTarget();
                    if (target instanceof ProxyAware) {
                        System.out.println("target:" + target);
                        System.out.println("bean:" + bean);
                        ((ProxyAware) target).setProxy(bean);
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            return bean;
        }

        @Override
        public int getOrder() {
            return Integer.MIN_VALUE;
        }
	}

熟悉BeanPostProcessor的同学应该一眼就能看出问题：<font color='red'>getOrder()方法的返回值是Integer.MIN_VALUE，</font>对，这就是导致自引用没有被赋值的真正原因。

#### BeanPostProcessor介绍

通过Spring API可知，BeanPostProcessor用于bean初始化的一些逻辑处理，它会对当前IoC容器中的所有bean进行处理。若当前IoC容器中有多个BeanPostProcessor，那么这些processor会按照一定的排序规则（后面讲解怎么排序）排序，组成一个处理器链。

![](https://github.com/yangguangyong/yangguangyong-s-blog/blob/master/assets/2017/04/beanpostprocessor.png)

初始化方法前执行postProcessBeforeInitialization()方法，初始化方法后执行postProcessAfterInitialization()方法。

这里不得不重点介绍AnnotationAwareAspectJAutoProxyCreator类，该类也是BeanPostProcessor的一个子类。它的postProcessAfterInitialization会创建一个动态代理类并返回该代理类实例。由此猜想：如果我们自定义的BeanPostProcessor优先级高于AnnotationAwareAspectJAutoProxyCreator类。根据上图，自定义类的postProcessAfterInitialization方法比AnnotationAwareAspectJAutoProxyCreator类的postProcessAfterInitialization方法先执行，此时的bean对象肯定不是代理类对象。就会导致proxyObj对象没有被赋值，导致抛空异常。

#### 创建IoC容器时初始化BeanPostProcessor过程

阅读Spring创建bean源码可知，在bean初始化过程会执行每个BeanPostProcessor的postProcessAfterInitialization方法：

	@Override
    public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
            throws BeansException {

        Object result = existingBean;
        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
            result = beanProcessor.postProcessAfterInitialization(result, beanName);
            if (result == null) {
                return result;
            }
        }
        return result;
    }

getBeanPostProcessors()方法返回AbstractBeanFactory类的BeanPostProcessor List属性，在IoC容器初始化时就已经将所有的BeanPostPorcessor实例按照规定排序规则添加到该list属性中。

IoC容器初始化并注入BeanPostProcessor过程：

- 创建一个IoC容器：


	// 创建一个IoC容器
    ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
    // 进入到ClassPathXmlApplicationContext构造方法
	public ClassPathXmlApplicationContext(String configLocation) throws BeansException {
		this(new String[] {configLocation}, true, null);
	}
	// 最终调用到这个构造方法
    public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)
			throws BeansException {

		super(parent);
		setConfigLocations(configLocations);
		if (refresh) {
			refresh();
		}
	}

- 进入refresh()方法，其中有这样一条语句：


    // Register bean processors that intercept bean creation.
    registerBeanPostProcessors(beanFactory);

- 跟进去，最终到PostProcessorRegistrationDelegate#registerBeanPostProcessors()方法中。这个方法的主要目的是将当前已定义的所有BeanPostProcessor实例按照一定排序规则添加到AbstractBeanFactory保存BeanPostProcessor List属性中。方法比较长，就不贴代码了。

BeanPostProcessor排序规则：

- 实现PriorityOrdered接口的优先级最高，若都实现该接口则根据getOrder()返回值排序，值越小，优先级越高；值相同，按照Spring加载bean的先后顺序排序；
- 实现Ordered接口的其次，若都实现该接口则根据getOrder()返回值排序，值越小，优先级越高；值相同，按照Spring加载bean的先后顺序排序；
- 没有实现任何排序接口的BeanPostProcessor排第三；
- 最后是实现了MergedBeanDefinitionPostProcessor接口的bean， MergedBeanDefinitionPostProcessor本身也继承了BeanPostProcessor。

回到上面的猜想：只要我们实现的BeanPostProcessor优先级高于AnnotationAwareAspectJAutoProxyCreator类，那就会抛异常。

先看看源码，AnnotationAwareAspectJAutoProxyCreator的优先级是怎么设置的：

- 实现Ordered接口
- 设置order值为Integer.MIN_VALUE

#### 异常复现

##### 情况1

- 条件：自定义BeanPostProcessor实现Ordered接口且返回Integer.MAX_VALUE
- 猜想结果：优先级比AnnotationAwareAspectJAutoProxyCreator的低，自引用能正常被赋值
- 实际操作结果：断点PostProcessorRegistrationDelegate#registerBeanPostProcessors方法可知，此时的ProxyInjectingBeanPostProcessor对象被添加到实现Ordered接口的list中

![](https://github.com/yangguangyong/yangguangyong-s-blog/blob/master/assets/2017/04/condition_1.png)

自引用对象被赋值：

![](https://github.com/yangguangyong/yangguangyong-s-blog/blob/master/assets/2017/04/condition_1_result.png)

##### 情况2

- 条件：自定义BeanPostProcessor实现Ordered接口且getOrder返回Integer.MIN_VALUE
- 猜想结果：按照Spring加载bean的先后顺序，若自定义BeanPostProcessor在AnnotationAwareAspectJAutoProxyCreator之后，自引用能正常赋值；否则导致空异常。
- 实际操作结果：自定义BeanPostProcessor在AnnotationAwareAspectJAutoProxyCreator之前；多次操作发现这种条件下自定义BeanPostProcessor都是优先AnnotationAwareAspectJAutoProxyCreator。这里需要阅读Spring加载bean的流程了解为什么会出现这种情况

![](https://github.com/yangguangyong/yangguangyong-s-blog/blob/master/assets/2017/04/condition_2.png)

自引用对象没有被赋值：

![](https://github.com/yangguangyong/yangguangyong-s-blog/blob/master/assets/2017/04/condition_2_result.png)

##### 情况3

- 条件：自定义BeanPostProcessor实现PriorityOrdered接口
- 猜想结果：优先级比AnnotationAwareAspectJAutoProxyCreator高，自引用不能被赋值
- 实际操作结果：ProxyInjectingBeanPostProcessor已经被放入实现PriorityOrdered接口list中

![](https://github.com/yangguangyong/yangguangyong-s-blog/blob/master/assets/2017/04/condition_3.png)

自引用对象没有被赋值：

![](https://github.com/yangguangyong/yangguangyong-s-blog/blob/master/assets/2017/04/condition_3_result.png)

##### 情况4

- 条件：自定义BeanPostProcessor不实现Ordered，PriorityOrdered接口，或者实现了MergedBeanDefinitionPostProcessor接口
- 猜想结果：优先级比AnnotationAwareAspectJAutoProxyCreator低，自引用能成功被赋值
- 实际操作结果：

不实现Ordered，PriorityOrdered接口

![](https://github.com/yangguangyong/yangguangyong-s-blog/blob/master/assets/2017/04/condition_4_none.png)

自引用对象被赋值：

![](https://github.com/yangguangyong/yangguangyong-s-blog/blob/master/assets/2017/04/condition_4_result.png)

实现MergedBeanDefinitionPostProcessor接口

![](https://github.com/yangguangyong/yangguangyong-s-blog/blob/master/assets/2017/04/condition_4_merge.png)

自引用对象被赋值：

![](https://github.com/yangguangyong/yangguangyong-s-blog/blob/master/assets/2017/04/condition_4_result.png)
