### Java内存泄漏

Java语言的一个关键的优势就是它的内存管理机制。你只管创建对象，Java的垃圾回收器帮你分配以及回收内存。然而，实际的情况并没有那
么简单，因为内存泄漏在Java应用程序中还是时有发生的

下面就解释下什么是内存泄漏，它为什么会发生，以及我们如何阻止它的发生

#### 1. 什么是内存泄漏

内存泄漏的定义：对象已经没有被应用程序使用，但是垃圾回收器没办法移除它们，因为还在被引用着

要想理解这个定义，我们需要先了解一下对象在内存中的状态。下面的这张图就解释了什么是无用对象以及什么是未被引用对象

![](https://github.com/yangguangyong/yangguangyong-s-blog/blob/master/assets/2016/06/java_memory.png)

上面图中可以看出，里面有被引用对象和未被引用对象。未被引用对象会被垃圾回收器回收，而被引用的对象却不会。未被引用的对象当然
是不再被使用的对象，因为没有对象再引用它。然而无用对象却不全是未被引用对象。其中还有被引用的。就是这种情况导致了内存泄漏

#### 2. 为什么会发生内存泄漏

来先看看下面的例子，为什么会发生内存泄漏。下面这个例子中，A对象引用B对象，A对象的生命周期（t1-t4）比B对象的生命周期（t2-t3）
长的多。当B对象没有被应用程序使用之后，A对象仍然在引用着B对象。这样，垃圾回收器就没办法将B对象从内存中移除，从而导致内存问
题，因为如果A引用更多这样的对象，那将有更多的未被引用对象存在，并消耗内存空间

B对象也可能会持有许多其他的对象，那这些对象同样也不会被垃圾回收器回收。所有这些没在使用的对象将持续的消耗之前分配的内存空间

#### 3. 如何防止内存泄漏发生

下面是几条容易上手的建议，来帮助你防止内存泄漏的发生：

* 特别注意一些像HashMap、ArrayList的集合对象，它们经常会引发内存泄漏。当它们被声明为static时，它们的生命周期就会和应用程序一样长
* 特别注意事件监听和回调函数。当一个监听器在使用的时候被注册，但不再使用之后却未被反注册
* “如果一个类自己管理内存，那开发人员就得小心内存泄漏问题了” 通常一些成员变量引用其他对象，初始化的时候需要置空


#### 4. Java内存泄漏的分析与定位

内存泄漏现象：当程序抛出OutOfMemoryError时，这常常是内存泄漏的一个标志，此时，如何判断是否发生内存泄漏，一个解决办法是继续
监听GC的活动，看看随着时间流逝，内存使用是否会增加，如果有，则一定存在内存泄漏

如通过命令jstat -gcutil pid 1000(表示每隔1000毫秒显示一次)，查看Full GC的次数，若有大量的Full GC就要查询是否有内存泄漏的问题

定位内存泄漏

1）使用工具Memory/Analyzer, 对程序的heap文件(.hprof)进行分析

2）将.hprof文件导入Memory/Analyzer中，通过Detail即可知道是哪儿出现内存泄漏


#### 附加信息：JVM什么时候开始GC

Minor GC(新生代回收)的触发条件比较简单，Eden空间不足就开始进行Minor GC回收新生代；而Full GC(老年代回收，一般伴随一次Minor GC)则
有几种触发条件:

* 老年代空间不足
* PermSpace空间不足
* 统计得到的Minor GC晋升到老年代的平均大小大于老年代的剩余空间
