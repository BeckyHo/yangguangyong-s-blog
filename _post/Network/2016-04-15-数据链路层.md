### 数据链路层

数据链路层使用的信道主要有以下两种类型：

* 点对点信道: 这种信道使用一对一的点对点通信方式
* 广播信道: 这种信道使用一对多的广播通信方式，广播信道上连接的主机很多，因此必须使用专用
    的共享信道协议来协调这些主机的数据发送

#### 使用点对点信道

##### 数据链路和帧

先介绍链路和数据链路的概念

链路: 就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点

数据链路: 当需要在一条线路上传送数据时，除了必须有一条物理线路外，还必须有一些必要的通信
协议来控制这些数据的传输；把实现这些协议的硬件和软件加到链路上，就构成了数据链路

帧: 点对点信道的数据链路层协议数据单元

点对点信道的数据链路层在进行通信时的主要步骤如下:

* 结点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧
* 结点A把封装好的帧发给B的数据链路层
* 若结点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报上交给上面的网络层；否则丢弃这个帧

##### 三个基本问题

数据链路层不管使用哪种协议，以下三个问题都需要面对: 封装成帧， 透明传输和差错检测

###### 封装成帧

封装成帧就是发送端在IP数据报的前后分别添加首部和尾部，这样就构成了一个帧；接收端在收到
物理层提交的比特流后，就能根据首部和尾部的标记，从比特流中识别帧的开始和结束；因此，帧
的长度等于IP数据报的长度加上帧首部和帧尾部的长度

为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大于首部和尾部的长度；但是，没一种
链路层协议都规定了帧的数据部分的长度上限——`最大传送单元MTU(maximum transfer unit)`, 如
下图给出了帧的结构图

![](https://github.com/yangguangyong/yangguangyong-s-blog/blob/master/assets/2016/04/link_01.png)

当数据是ASCII码的文本文件时，帧头和帧尾可以使用特殊的帧定界符；控制字符SOH(start of header)
放在帧的最前面，表示帧的首部开始；另一个控制字符EOT(end of transmission)表示帧的结束；

`注意：SOT和EOT都是控制字符的名称，它们的十六进制编码分别是01(二进制是00000001)和04(00000100),`
`SOT(或EOT)并不是S,O,H(或E,O,T)三个字符；`

![](https://github.com/yangguangyong/yangguangyong-s-blog/blob/master/assets/2016/04/link_02.png)

当数据在传输中出现差错时，帧定界符的作用更加明显；如果接收端收到的是一个不完整的帧时就会丢弃
掉这个帧

###### 透明传输

前面介绍了帧定界符是使用专门指定的控制字符，因此，当传输的数据中任何8比特的组合一定不允许
和用作帧定界的控制字符比特编码一样，否则就会出现帧定界的错误

若数据是ASCII码的文本文件(ASCII码十进制数从32开始，即从键盘中输入的数据)，所以永远不会出
现对应二进制为00000001和00000100这样的字符，所以不管我们输入什么字符都可以封装成帧传输过去，
这样的传输就是透明传输

但是如果数据部分是非ASCII码的文本文件时，情况就不同了，如果数据中某个字节的二进制恰好和
SOH或EOT一样，数据链路层会错误地“找到帧的边界”，把部分帧手下，而把剩下的那部分数据丢弃

![](https://github.com/yangguangyong/yangguangyong-s-blog/blob/master/assets/2016/04/link_03.png)

上面出现的这种情况就不是“透明传输”，因为当遇到数据中碰巧出现字符“EOT”时就传不过去了；数据
中的“EOT”将被接收端错误地解释为“传输结束”的控制字符，而在其后面的数据因找不到“SOH”被接收端
当作是无效帧而丢弃；但实际上数据中出现的字符“EOT”并非控制字符而仅仅而二进制数据00000100

为了解决透明传输问题，就必须设法使`数据中`可能出现的控制字符“SOH”和“EOT”在接收端不被解释
为控制字符；具体方法是: 发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个
`转义字符ESC`, 在接收端的数据链路层在将数据送往网络层之前删除这个插入的转义字符；这种方法
称为`字节填充`, 如果转义字符也出现在数据中，处理方式也是一样的

###### 差错检测

比特在传输过程中可能会产生差错，1可能会变成0，而0也可能变成1，这就叫做`比特差错`;它只是传输
差错中的一种；为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施，
目前在数据链路层广泛使用了`循环冗余检验CRC`

循环冗余检验原理: 发送端先把数据划分为组，假设每组k个比特，例如待传送的数据M=101001(k=6),
CRC运算就是在数据M的后面添加供差错检测用的n位冗余吗，然后构成一个帧发送出去，一共发送
(k+n)位

n位冗余码的计算方式(模2运算):

假设待发送的数据M=101001(k=6), 假定除数P=1101(n=3),经过模2运算后的结果是: `商Q=110101,`
`余数R=001`; 这个余数R就作为冗余码拼接在数据M的后面发送出去；这种为了进行检错而添加的冗余码
常称为`帧检验序列FCS(Frame Check Sequence)`; 因此加上FCS后发送的帧是101001001共有(k+n)位

注意两者的区别: CRC是一种检错方法，而FCS是添加在数据后面的冗余码

___

在接收端把收到的数据以帧为单位进行CRC检验，把收到的每一个帧都除以相同的除数P(模2运算)，
然后检查得到的余数R; 如果在传输过程中无差错，那么经过CRC检验后得出的余数肯定是0

`最后强调一下，在数据链路层若仅仅使用循环冗余检验CRC差错检测技术，则只能做到对帧的无差错检测，`
`即：凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有`
`产生差错`

我们现在并没有要求数据链路层向网络层提供`可靠传输`的服务，所谓`可靠传输`就是：数据链路层
的发送端发送什么，在接收端就收到什么；传输差错可分为两大类：一类就是前面所说的最基本的
比特差错；而另一类传输差错则更复杂些，就是收到的帧并没有出现比特差错，但却出现了`帧丢失，帧重复或帧失序`
比如发送端连续传送三个帧：[#1]-[#2]-[#3],在接收端可能出现下面的情况：

* 帧丢失：收到[#1]-[#3](丢失[#2])
* 帧重复：收到[#1]-[#2]-[#2]-[#3](收到两个[#2])
* 帧失序：收到[#1]-[#3]-[#2]([#3]比[#2]先收到)

现在因特网广泛使用的数据链路层协议都不使用确认和重传机制，即不要求数据链路层向上提供可靠
传输的服务；如果在数据链路层传输数据时出现了差错并且需要进行改正，那么改正差错的任务就由
上层协议（比如运输层的TCP）来完成
