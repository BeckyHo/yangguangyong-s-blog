### Mysql limit优化

好久没写文章了，自己变懒了，技术也退步了，现在的战斗力真是渣渣，难受~~~。 现在开始，我又回来啦，阿里还有好多优秀的技术
等着我去学习了，哈哈

上星期做了差旅报表需求，有个功能需要用到分页显示，第一反应就是order limit, 哈哈，然后我又想起了7月份面试cvte时被问到
limit优化时没有回答上来，现在是时候做个总结了。

#### 目录

* limit语法
* limit原理分析与优化点分析
* limit优化实践

#### limit语法

 mysql[官网](http://dev.mysql.com/doc/refman/5.7/en/limit-optimization.html)对limit的语法介绍， 示例：
 SELECT ... FROM single_table ... ORDER BY non_index_column [DESC] LIMIT [M,]N 总结如下:

 * 如果M为指定，返回前N行
 * 如果M指定，跳过前M行，返回之后的N行

**mysql下标从0开始**

#### limit原理分析与优化点分析

执行过程: 排序时有个大小为size的缓冲区，如果待排序的N行记录比缓冲区大小还小，服务器就可以避免文件合并
且可以在内存中完成排序:

* 扫描表, 将我们选择的每行记录对应的列插入到缓冲区的排序队列中，如果队列已满，删除队列中的最后一行
* 返回队列的前N行.(如果指定了M， 跳过前M行且返回后面的N行)

比如当我执行 select * from user order by id limit 1000, 1;时，它会取出前1001行记录排序，并返回1000
行后的那行，也就是最后一行。这就属于取出了很多没有用到的数据，而且，当我们取的数据越大，也就是M越大，
放到缓存队列中排序的也越多，当超过sort buffer的大小时，就不能在内存中进行了，这样会更慢。

所以优化的点是： 如何只取出我们想要的那部分数据并返回了？

#### limit优化实践

方式1： 使用where，比如 select * from user where id > 1000 order by id limit 2, 3; 这时的执行过程是：
取出id > 1000的行，从之后的第二行开始，返回三条记录，此时使用explain解释这条sql，发现它只扫描了
5条记录。

问题: 如何知道需要id > 1000之后的数据了？ 怎么记录这个1000?

可以这么做，在用户第一次翻页到某个offset时，在redis中直接保存该offset对应的id是多少，也就是[offset, id]对，当有其他请求
来查找offset之后的数据时，可以从该offset对应id的位置之后往后扫描。如果列表的数据发生了变化，需要及时将redis中保存的[offset, id]删除掉
