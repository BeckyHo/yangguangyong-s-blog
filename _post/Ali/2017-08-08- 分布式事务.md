### 分布式事务

当今流行微服务架构，一次简单的操作可能会涉及到多个服务和不同数据库实例。这就涉及到不同数据库实例之间数据一致性问题。

我们往往为了可用性和分区容错性，放弃强一直性，转而追求最终一致性。大部分业务场景下，我们是可以接受短暂的不一致性的。

#### 最终一致性解决方案

举例：A给B转账100元，A跟B属于不同的开户行，下面基于该实例展开最终一致性的集中解决方案。

##### 两阶段提交

两阶段提交哦啊需要有一个协调者，来协调两个操作之间的操作流程。当参与方更多时，需要处理的异常情况就更多，更复杂。

参与者需要实现两阶段提交协议，pre commit阶段需要锁住相关资源，commit或rollback时分别进行实际提交后释放资源。

我们一般会假设预提交成功后，提交或者回滚肯定是成功的（由参与者来保障）。当提交或者回滚失败时，协调者只能选择继续重试，这要求下游接口要做幂等。但是，下游出现故障，有时通过重试并不能解决问题（消息阻塞），这是需要定时的出去中间状态的逻辑。

##### 异步确保（没有事务消息）

异步化不只是为了一致性，有时更多的考虑响应时间，下游稳定性等因素。

该方法关键是要有两个消息表；另外，一般会有个队列，而且我们一般都会假设这个MQ不丢消息且不支持事务消息。

基本思路就是：

- 消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交。
- 消息消费方，也需要一个消息表，用来做幂等，重试。消费方收到并消费消息，完成自己的业务逻辑后修改消息表中消息状态。
- 消息生产方定时扫描本地消息表，把还没有处理完成的消息重发一遍。

阿里商旅预订机票流程就是基于这个思想

##### 异步确保（事务消息）

思想是：我们只要把消息扔给MQ，那么这个消息肯定会被消费成功。生产方不用担心消息发送失败，也不用担心消息会丢失。其实就是把第二种思想的很多杂活给MQ做了。