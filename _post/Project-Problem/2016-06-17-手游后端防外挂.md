### 手游后端防外挂

要做防外挂，首先需要知道玩家作弊的方式有哪些，以下是从网上总结的玩家作弊方式：

1. 反编译并修改源码，根据需要自行定制作弊的客户端
2. 修改客户端运行内存，使用OpenProcess工具以适当的权限打开游戏进程，找出数据段范围，然后
    使用ReadProcessMemory和WriteProcessMemory对该进程的地址范围进行扫描和修改，并以
    类似定时器的方法实现内存内容锁定
3. 修改客户端的配置表
4. 用抓包工具修改协议内容(WPE工具)
5. 利用游戏BUG

对于1，2两种情况，最好的处理方式就是不要相信任何客户端传送过来的数据，所有数据都有服务端产出

对于第3种情况，可以先将配置表加密并压缩，在程序运行时再解密解压缩，使用配置表

对于第4种情况，可以对协议加密，包编号，通过对协议加密和协议完整性校验，能保证协议字段的合法性

第5种情况，找测试

#### 我们项目组的防外挂处理

1. 关键数据都是由服务端产出的
2. 前端对配置表进行加密，在程序加载时在解密使用
3. 服务端对数据字段加密，并对收到的包进行包序号校验，若序号不对，立刻将玩家踢下线

目前我们项目的防外挂主要是针对战斗的防外挂，首先，产品规定哪些战斗需要做防外挂的校验，
每种战斗的校验标准是什么（包括玩家最低等级，队伍最高战斗力和通关时间等参数）；若玩家
战斗结果有一个不符合最低标准，就要对这场战斗进行校验

校验的方式是收集玩家战斗之前的数据，发送给Lua，模拟这场战斗，得到校验的战斗
玩家对怪物造成的伤害值，用该值与之前前端发送过来的伤害值进行比较，若两者差值在规定范围区间内，说明玩家是正常操作的，否则视为作弊，此时会记录玩家的信息，等待产品人员的处理.

#### 分析

我们后端使用的是Java，在做战斗验证时我们的做法是收集数据，然后调用前端的Lua代码，这
会涉及到效率问题，因为前端自己战斗时(C++调Lua)可能是1～2秒钟，而Java调Lua有时会到5秒
种以上，相比于C++来说这确实是比较慢的操作了

一种提高战斗验证的操作是搭建一个战斗服务器，战斗服务器使用C++调用Lua; 当需要做战斗
验证时，把数据收集后发送到战斗服务器上，然后执行C++调Lua操作，这样会比较快一些，同时
减轻后端服务器的压力
