### 分布式系统 session 问题

> 本文来自网络整理

#### 目录
* 什么是session， 什么是cookie， 他俩有啥联系和区别；
* 为什么要在多台服务器间进行session的共享同步；
* 有哪些方法来实现session同步。

#### 什么是session， 什么是cookie， 他俩有啥联系和区别

##### cookie
指某些网站为了辨别用户身份，进行session跟踪而存储在用户本地终端上的数据。cookie是由服务器端生成，发送给user-agent，浏览器会将cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该cookie给服务器端

##### session
session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的web页面之间跳转时，存储在session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的网页时，如果该用户还没有会话，则web服务器将自动创建一个session对象。当会话过期或被放弃后，服务器将终止该会话。

---

简单来说，浏览器请求服务器，服务器为了区别不同的用户请求，就需要给他们打上标签。比如：发放一个访问令牌给客户端，发放的过程是通过在http请求返回的时候，设置http的header， set-cookie来实现的。

每个set-cookie里一般都会含有设置的key/value，过期时间，以及域和路径。当浏览器接收到这样的返回头以后，就把它保存到本地，以后每次发送请求的时候，就会把它带上。

一般服务器会发送一些类似访问令牌，用户ID等cookie，这样当用户访问对应网站，他就把你认出来了。像Java的服务器，还会有一些类似jsession_id的cookie，服务器采用一定的算法，生成一个一定长度的字符串"angOwberup"，然后发放给浏览器：Set-Cookie: jssesion_id=angOwberup，当浏览器收到这个cookie以后，会把这个key/value保存到本地，以后每次去服务器请求都带上。

与此同时，服务器把这个字符串"angOwberup"作为key，把一个叫做User的类实例作为value，然后put到一个map容器里：map.put("angOwberup", user); 当浏览器请求来的时候，服务器就会getCookie("jsession_id")。把浏览器带来的字符串取出来，然后用这个字符串去map里找找，看看有没有对应的User对象：map.get(sessionId)，如果找到了，说明就找到了这个用户的id, nickname等信息，直接就可以在网页上显示"老王你好，欢迎回来"，如果没有找到，有可能就跳到登录页面，让用户做登录。

我们把用户在一定时间内访问某个网站时，请求不同页面的过程叫做一个会话，也就是session。在同一个session里，我们可以记录用户访问的状态和信息，这样，那个类似于map的容器就是session管理器了。

总结下cookie和session区别：

* cookie是服务器发送给客户端的一些标识，让客户端记住每次请求的时候带上，以区分不同的用户
* session是服务器存放在自己那里的用户相关的数据，从每次用户带来的cookie中提取出来，回复一个之前访问的历史或者相关环境

##### session的管理

上面说了，服务器用了一个类似于map的容器来管理session，那具体来看，这个map是怎么来实现的了？

不同的服务器，不同的语言框架都有不同的实现，比如java的服务器，有的是用文件方式存储的，有的是用内存cache的方式来存储的，还有的语言的服务器将数据做加密，然后设置成cookie，存到了客户端（浏览器）。那这些实现方式都有哪些优缺点呢？

###### 文件方式

这种方式，将文件作为一个map，当新增一个数据的时候，就在文件中增加类似这样的一条数据：

angOwberup => data={"user":{"id":1, "nickname":"张三"}}; expire="2017-01-01 00:00:00"

这种方式的好处，就是能够存储大量的用户session，使得这个session有效期可以比较长。不过这个方式也有对应的问题，就是文件操作比较麻烦。比如，有一个用户的session过期了，需要删掉这条记录，那这个文件就需要挪动或重写。

###### cache方式

有好多web端的逻辑服务器都采用这种方式。这种方式好处非常明显，就是实现起来非常简单。将所有数据放入到内存cache中。如果有实效，直接内存删除就可以了。不过带来的问题也很明显，当服务器重启以后，所有session都丢失了。或者当有大量用户登录，就会很快让cache被充满，然后大量session被LRU算法淘汰，造成session的大量失效，使得用户需要反复登录等操作。

###### cookie方式

这种方式是最偷懒的方式。就是我服务器任何数据都不存，我把你们所有的客户端当作我的存储器，我就需要一个加密和解密操作。当然这种方式最大的好处就是实现极其简单，不过问题也是很明显的，就是客户端要记录大量信息，同时还要保证加密信息的安全。如果session里要存放大数据，这种方式就不是很适合了。

除了上述说到的优缺点以外，文件方式和cache方式还有另外一个问题，就是当我有不止一台服务器的时候，不同服务器间的session数据共享就成问题了。比如，最初我只有一台服务器1，他的session里记录了user-1和user-2的数据。这个时候，我需要增加一台服务器2。当nginx把用户的请求转发到服务器2的时候，他就傻眼了：用户带了一个jsession_id=angOwberup这个的cookie过来，而在他的session管理器里却找不到这样一个session数据，那该怎么办？

有了上面的情况，我们就必须要去考虑，如何在这个服务器之间实现session同步这个操作。常见的做法有以下几种，我们逐个来看看

#### session的同步

有了上面的情况，我们就必须要去考虑，如何在多个服务器之间实现session同步这个操作。常见的做法有以下几种

##### 进程间通信传递session数据

这是最容易想到的一个方法，我们在不同的server服务里开一个socket，然后用socket来将相互拥有的session数据进行传递。

这种方式的好处很明显，就是原理简单明了；坏处也很明显，就是同步合并过程复杂，还容易造成同步延迟。比如，某个用户在server-1登录了，server-1存储了这个用户的session，当准备将数据同步给server-2的时候，由于用户访问实在太快了，server-2还没有收到server-1传来的session数据，用户访问就已经来了。这个时候，server-2就不能识别这个用户，造成用户需要再次登录。

而且，当有成千上万台服务器的时候，session同步就是一个噩梦，每一台服务器都要将自己拥有的session广播给其他所有机器，而且还要随机进行，不能停歇。

##### cookie存储方式

我们在上面讲到了一个很偷懒的方式，就是把session数据做加密，然后存储到cookie中。用户请求到了，就直接从cookie读取，然后做解密。这种方式真是把分布式思想发挥到了一个相当的高度。他把用户也当作分布式的一员，你要访问数据，那你就自己携带他，每次到服务器的时候，我们的服务器就只负责解密

对于session里只存放小数据，并且加密做的比较好的系统来讲，这是一个比较好的选择，他实现超级简单，而且不用考虑数据的同步。

不过如果要往session里存放大数据的情况就不是太好处理，或者安全性要求很高的系统，也不是太好的一个方式。

##### cache集群或者数据库做session管理

我们也可以采用另外一种架构来解决session同步问题，那就是引入统一session接入点。我们session放入到cache集群或者数据库中，每次请求的时候，都从他们中来获取。这样，所有的机器都能获取到最新的session数据。这种方案也是很多大型网站采用的解决方案。他实现起来相对简单，而且效率很高，安全性也不错。

大家如果仔细观察一下baidu或者google，当你登录的时候，他们可能会让你跳转到passport.baidu.com或者accounts.google.com这两个域名之下。这两个就是他们用来做用户登录和类似session管理的一个地方。当一个访问请求来的时候，server就从cookie里取类似session_id的东东，然后用这个东东去passport服务去请求用户的session数据。

这种方式的好处就在于：

* 可以非常方便的扩展用户登录的数量以及存储数据的大小，比如百度，N亿用户的session都在这个系统里进行管理
* 方便做性能优化，如果用cache集群的方案，如果cache有机器坏掉，那么就会造成一部分用户session失效；如果用数据方案，如果量太大，有可能会出现性能问题。而这种方案在实现的时候，可以用cache和数据库结合的实现方式，保证高效和稳定。同时，针对一些接口，可以做性能的优化，提升查询效率
* 对外封闭，保证数据安全。这种方式还有一个好处，就是可以将加密算法，密钥等封闭在系统内部，对外只暴露接口，使得数据安全性更有保障。

不过，这种方式也有自己的问题，就是运维相对更复杂，有可能需要专门的团队去管理这些系统。

##### 总结

关于session同步，其实方案有很多，没有哪个方案是最好的，只有某一种方案是最适合你现在的架构的。
